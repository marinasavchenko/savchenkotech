<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>savchenko.tech</title>
    <link>https://savchenko.tech/</link>
    <description>Recent content on savchenko.tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://savchenko.tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Prisma&#39;s algorithm. Greedy. Algorithms series</title>
      <link>https://savchenko.tech/posts/greedy/</link>
      <pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/greedy/</guid>
      <description>Prim&amp;rsquo;s algorithm is a greedy algorithm for computing Minimum Spanning Tree (MST).
Greedy algorithms is a technique used in designing and analyzing efficient algorithms. They typically apply to optimization problems in which you make a set of choices in order to arrive at an optimal solution. A greedy algorithm always makes the choice that looks best at the moment. It makes a locally optimal choice in hope that this choice leads to globally optimal solution.</description>
    </item>
    
    <item>
      <title>Breadth First Search. Algorithms series</title>
      <link>https://savchenko.tech/posts/bfs/</link>
      <pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bfs/</guid>
      <description>In this article we will be looking at Single-source shortest path problem. The classical method for solving it is Breadth First Search (BFS). In BFS we want to explore the vertices in order of their distance from the source. It could be achieved with queue and filling in last edge on the shortest path for every vertex.
Unit test should check if the shortest path is returned, when there is longer path in the graph.</description>
    </item>
    
    <item>
      <title>Depth First Search. Algorithms series</title>
      <link>https://savchenko.tech/posts/dfs/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/dfs/</guid>
      <description>Graph algorithms solve many problems in computer science and are fundamental to the field. Depth First Search (DFS) is one of them.
Representation of a graph Before we dive into DFS we need to understand Graph structure and terminology.
Graph is a set of vertices and a collection of edges that each connect a pair of vertices.
Examples of a Graph would be:
 in finance : Currency is a vertex, transaction is an edge in transportation : Street intersection is a vertex, route is an edge  Vertex 1 is connected to Vertex 2 when there is an edge between them.</description>
    </item>
    
    <item>
      <title>Hash table. Algorithms series</title>
      <link>https://savchenko.tech/posts/hashtable/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/hashtable/</guid>
      <description>Dictionary operations (INSERT, SEARCH and DELETE) are required by many applications. One very effective data structures for implementing dictionaries is hash table. The average time to search for an element in hash table is O(1).
Hash table ia unordered symbol table where key is interpreted as an array index and value associated with key &amp;lsquo;i&amp;rsquo; is stored in array entry &amp;lsquo;i&amp;rsquo;.
Two main parts in hash algorithm are hash function and collision resolution method.</description>
    </item>
    
    <item>
      <title>Red Black Binary Search Tree: Part 2 delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst2/</link>
      <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst2/</guid>
      <description>To implement delete() method we need to take care about helper methods first. First we will take a look at deleteMin().
DELETE MIN Test cases for deleteMin() should check that:
 minimal element is not present tree is balanced, which means:  there is no more than 1 left RED links in the row there is no right RED link root should be always BLACK     @Test  void shouldDeleteMinElement() {  RedBlackBinarySearchTree&amp;lt;Integer, String&amp;gt; brBinarySearchTree = createRedBlackBST();   brBinarySearchTree.</description>
    </item>
    
    <item>
      <title>Red Black Binary Search Tree: Part 1 put. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst/</guid>
      <description>Red-Black Tree is a Binary Search Tree with one extra bit of storage per node - color, which can be either RED or BLACK. We need it to keep BST &amp;ldquo;balanced&amp;rdquo;, that means basic dynamic set operations will be fast (guaranteed time O(lg n) ).
Red-black tree has next properties:
 Every node is RED or BLACK The root id always BlACK Every null leaf is black If a node is RED, then both children are BLACK For each node, all simple paths from the node to descendant leaves contain the same number of BLACK nodes.</description>
    </item>
    
    <item>
      <title>Binary Search Tree: Part 2 min, floor, delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst2/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst2/</guid>
      <description>An important feature of Binary Search Tree (BST) is that it allows keeping keys in order. So we are able to apply wide range of operations that involves relative key order.
In this article we will take a look at some of them.
As in the previous part we will use TDD to ensure algorithm correctness.
MIN min() method should return the smallest key.
 @Test  void shouldReturnMinKeyInBST() {  BinarySearchTree&amp;lt;Integer, String&amp;gt; bst = new BinarySearchTree&amp;lt;&amp;gt;();  bst.</description>
    </item>
    
    <item>
      <title>Rust. The promise of fearless concurrency</title>
      <link>https://savchenko.tech/posts/rust/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rust/</guid>
      <description>Rust has been getting 1st place in Stack Overflow’s annual developer survey “most loved programming language” since 2016. Google develops parts of Android with Rust. Amazon Web Services (AWS) has used Rust since 2017 for its serverless computing offerings, AWS Lambda and AWS Fargate. Microsoft writes components of its Azure platform including a security daemon for its Internet of Things (IoT) service.
Big addition to this popularity wave was Linus Torvald&amp;rsquo;s announcement on Open Source Summit that Rust can be added to the Linux kernel in the next major release.</description>
    </item>
    
    <item>
      <title>Binary Search Tree: Part 1 put, get, size. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst/</guid>
      <description>Development of computational infrastructure would not become available without effective searching algorithms. One type of such algorithms is symbol tables. Term symbol table is used to describe a mechanism where we can save information (value) and later retrieve it by specified key. Symbol tables sometimes also referred as dictionaries.
There are three main classic data structures that can support efficient symbol-table implementations: binary search trees, red -black trees and hash tables.</description>
    </item>
    
    <item>
      <title>Waiting for Loom&#39;s virtual threads...</title>
      <link>https://savchenko.tech/posts/loom/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/loom/</guid>
      <description>Since Alan Turing time we came from running one program at a time on bare metal to running millions of java virtual threads. Which is absolutely impressive.
Why? Why should we care about threads at all? The answer is - performance. Applying concurrency can improve performance in a few ways:
 reducing latency (process one task faster) hiding latency (process another task while waiting) increasing throughput (process more tasks).  Current java concurrency implementation is based on the rule that one Java thread equals exactly one OS thread (one-to-one mapping).</description>
    </item>
    
    <item>
      <title>Pattern matching in Java</title>
      <link>https://savchenko.tech/posts/patternmatching/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/patternmatching/</guid>
      <description>To reduce duplication (boilerplate) in code pattern matching with if statements and the instanceof operator was introduced with Java version 16.
 Pattern matching is a technique of controlling program flow that only executes a section of code that meets certain criteria.
 Pattern matching with if and instanceOf In code example without pattern matching cast is needed.
 public Integer objectToString(Object object) {  if (object instanceof String) {  String string = (String) object;  return Integer.</description>
    </item>
    
    <item>
      <title>Common programming paradigms overview</title>
      <link>https://savchenko.tech/posts/paradigms/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/paradigms/</guid>
      <description>Why do we care about programming paradigms?
The answer is they help us to align with architectural concerns like boundaries, location and accessing data and algorithm foundation in the modules.
Programming paradigms are ways of programming that are reflected in language features. They tell us which structures to use and when to use them.
There are 3 such main paradigms:
  structured programming
  object-orient programming
  functional programming.</description>
    </item>
    
    <item>
      <title>SOLID principles</title>
      <link>https://savchenko.tech/posts/solid/</link>
      <pubDate>Fri, 25 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/solid/</guid>
      <description>When building software systems we need to avoid a mess at any cost. The more messy software is, the more expensive is to change and maintain it.
Main design smells that lead to costs increase are:
 rigidity - when tight coupling leads to major rebuild and makes it harder to make changes fragility - when inappropriate and insufficient isolation of software parts leads to one change cause other unrelated modules crash or misbehave immobility - when software structures can not be reused  To avoid these design smells and make our software easy to change, understand and reuse we need a guide how to combine functions, data structures and classes - design principles.</description>
    </item>
    
    <item>
      <title>gRPC server side implementation using Spring</title>
      <link>https://savchenko.tech/posts/grpcservice/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/grpcservice/</guid>
      <description>This article is describing how to create gRPC service implementation using Spring Boot.
You can find more details about gRPC in &amp;ldquo;Is gRPC a better choice over REST?&amp;rdquo;.
To create gRPC service you need to complete 3 tasks:
 Create module for proto model and service definitions. Create module with server side implementation of gRPC. Test service with BloomRPC.  1. Generation of Proto model and service definition It will be Maven project.</description>
    </item>
    
    <item>
      <title>Tips for more effective public speaking</title>
      <link>https://savchenko.tech/posts/effectivecommunication/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/effectivecommunication/</guid>
      <description>Effective public speaking is a crucial to your personal, professional and social success. At the same time many developers luck the confidence to communicate clearly, which leads to missing out on career opportunities.
The biggest threat to our confidence is anxiety, in other words - being nervous. Anxiety - is a signal that we are doing something important. So you can not get rid of it completely. But we do not want anxiety to prevent us from being ourselves and let our skills shine.</description>
    </item>
    
    <item>
      <title>Is gRPC a better choice over REST?</title>
      <link>https://savchenko.tech/posts/grpcvsrest/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/grpcvsrest/</guid>
      <description>Communication protocols play essential role in every modern software system. With increasing popularity of Microservice architecture inter-process communication techniques become even more important.
The most common way to build request-response style communication is RESTful services. However, REST can be inefficient and error-prone to use in microservices. We would need something more scalable, loosely coupled and efficient. That is where gRPC will shine.
 gRPC (the “g” stands for something different in every gRPC release) is an inter-process communication technology that allows you to connect, invoke, operate, and debug distributed heterogeneous applications as easily as making a local function call.</description>
    </item>
    
    <item>
      <title>Team framework</title>
      <link>https://savchenko.tech/posts/teamwork/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/teamwork/</guid>
      <description>If I have seen further than others, it is by standing upon the shoulders of giants.
Isaac Newton
 Programming is not about coding it is about working with people. Sounds easy, isn&amp;rsquo;t it? You put people in one room, and somehow it all should magically work out.
The problem is that most people do not even come across as they intend to. I am not even talking about solving complex issues.</description>
    </item>
    
    <item>
      <title>Once again about the testing</title>
      <link>https://savchenko.tech/posts/testing/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/testing/</guid>
      <description>Effective software testing should minimize the amount of defects and maximize stability of the product. Achieving it in practice can be quite effortful. What to test? How many test cases? Who should test?
Questions what to test and on which level can be answered by testing pyramid. 1. Unit testing Unit testing is a type of testing where system under test is an individual unit and is done during the coding phase.</description>
    </item>
    
    <item>
      <title>Continuous learning</title>
      <link>https://savchenko.tech/posts/learningframework/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/learningframework/</guid>
      <description>Learning is the crucial tool on the road to mastery and true driver of the software craftsman career. There is no way one can become successful at software development without becoming an expert in learning.
I believe that effective learning contains of components so called learning framework. This framework can be applied to any kind of learning. It does not meter if it is learning the language or preparing for the OCP (Oracle Certified Professional) exam.</description>
    </item>
    
    <item>
      <title>About Maryna</title>
      <link>https://savchenko.tech/about/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/about/</guid>
      <description>I am Maryna Savchenko: software engineer, true believer in Software craftsmanship, Clean code and TDD. Enjoy learning and working with new programming languages, listening to IT podcasts, working on exciting and ambitious projects.
I started this blog to share my experience and thoughts about software engineering practices, technologies and skill set improvement.</description>
    </item>
    
    <item>
      <title>Contact information</title>
      <link>https://savchenko.tech/contactinformation/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/contactinformation/</guid>
      <description>  Email address maryna@savchenko.tech LinkedIn https://www.linkedin.com/in/maryna-savchenko-7061a8223/ Github https://github.com/marynasavchenko Twitter @SavchenkoTech  </description>
    </item>
    
  </channel>
</rss>
