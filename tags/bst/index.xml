<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bst on savchenko.tech</title>
    <link>https://savchenko.tech/tags/bst/</link>
    <description>Recent content in bst on savchenko.tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://savchenko.tech/tags/bst/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Red black binary search tree: Part 1 put. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst/</guid>
      <description>Red-black tree is a binary search tree with one extra bit of storage per node - color, which can be either RED or BLACK. We need it to keep BST &amp;ldquo;balanced&amp;rdquo;, that means basic dynamic set operations will be fast (guaranteed time O(lg n) ).
Red-black tree has next properties:
 Every node is RED or BLACK The root id always BlACK Every null leaf is black If a node is RED, then both children are BLACK For each node, all simple paths from the node to descendant leaves contain the same number of BLACK nodes.</description>
    </item>
    
    <item>
      <title>Binary search tree: Part 2 min, floor, delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst2/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst2/</guid>
      <description>An important feature of Binary search tree (BST) is that it allows keeping keys in order. So we are able to apply wide range of operations that involves relative key order.
In this article we will take a look at some of them.
As in the previous part we will use TDD to ensure algorithm correctness.
MIN min() method should return the smallest key.
 @Test  void shouldReturnMinKeyInBST() {  BinarySearchTree&amp;lt;Integer, String&amp;gt; bst = new BinarySearchTree&amp;lt;&amp;gt;();  bst.</description>
    </item>
    
    <item>
      <title>Binary search tree: Part 1 put, get, size. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst/</guid>
      <description>Development of computational infrastructure would not become available without effective searching algorithms. One type of such algorithms is symbol tables. Term symbol table is used to describe a mechanism where we can save information (value) and later retrieve it by specified key. Symbol tables sometimes also referred as dictionaries.
There are three main classic data structures that can support efficient symbol-table implementations: binary search trees, red -black trees and hash tables.</description>
    </item>
    
  </channel>
</rss>
