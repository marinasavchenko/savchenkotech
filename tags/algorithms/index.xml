<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on savchenko.tech</title>
    <link>https://savchenko.tech/tags/algorithms/</link>
    <description>Recent content in algorithms on savchenko.tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://savchenko.tech/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Depth First Search. Algorithms series</title>
      <link>https://savchenko.tech/posts/dfs/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/dfs/</guid>
      <description>Graph algorithms solve many problems in computer science and are fundamental to the field. Depth First Search (DFS) is one of them.
Representation of a graph Before we dive into DFS we need to understand Graph structure and terminology.
Graph is a set of vertices and a collection of edges that each connect a pair of vertices.
Examples of a Graph would be:
 in finance : Currency is a vertex, transaction is an edge in transportation : Street intersection is a vertex, route is an edge  Vertex 1 is connected to Vertex 2 when there is an edge between them.</description>
    </item>
    
    <item>
      <title>Hash table. Algorithms series</title>
      <link>https://savchenko.tech/posts/hashtable/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/hashtable/</guid>
      <description>Dictionary operations (INSERT, SEARCH and DELETE) are required by many applications. One very effective data structures for implementing dictionaries is hash table. The average time to search for an element in hash table is O(1).
Hash table ia unordered symbol table where key is interpreted as an array index and value associated with key &amp;lsquo;i&amp;rsquo; is stored in array entry &amp;lsquo;i&amp;rsquo;.
Two main parts in hash algorithm are hash function and collision resolution method.</description>
    </item>
    
    <item>
      <title>Red Black Binary Search Tree: Part 2 delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst2/</link>
      <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst2/</guid>
      <description>To implement delete() method we need to take care about helper methods first. First we will take a look at deleteMin().
DELETE MIN Test cases for deleteMin() should check that:
 minimal element is not present tree is balanced, which means:  there is no more than 1 left RED links in the row there is no right RED link root should be always BLACK     @Test  void shouldDeleteMinElement() {  RedBlackBinarySearchTree&amp;lt;Integer, String&amp;gt; brBinarySearchTree = createRedBlackBST();   brBinarySearchTree.</description>
    </item>
    
    <item>
      <title>Red Black Binary Search Tree: Part 1 put. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst/</guid>
      <description>Red-Black Tree is a Binary Search Tree with one extra bit of storage per node - color, which can be either RED or BLACK. We need it to keep BST &amp;ldquo;balanced&amp;rdquo;, that means basic dynamic set operations will be fast (guaranteed time O(lg n) ).
Red-black tree has next properties:
 Every node is RED or BLACK The root id always BlACK Every null leaf is black If a node is RED, then both children are BLACK For each node, all simple paths from the node to descendant leaves contain the same number of BLACK nodes.</description>
    </item>
    
    <item>
      <title>Binary Search Tree: Part 2 min, floor, delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst2/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst2/</guid>
      <description>An important feature of Binary Search Tree (BST) is that it allows keeping keys in order. So we are able to apply wide range of operations that involves relative key order.
In this article we will take a look at some of them.
As in the previous part we will use TDD to ensure algorithm correctness.
MIN min() method should return the smallest key.
 @Test  void shouldReturnMinKeyInBST() {  BinarySearchTree&amp;lt;Integer, String&amp;gt; bst = new BinarySearchTree&amp;lt;&amp;gt;();  bst.</description>
    </item>
    
    <item>
      <title>Binary Search Tree: Part 1 put, get, size. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst/</guid>
      <description>Development of computational infrastructure would not become available without effective searching algorithms. One type of such algorithms is symbol tables. Term symbol table is used to describe a mechanism where we can save information (value) and later retrieve it by specified key. Symbol tables sometimes also referred as dictionaries.
There are three main classic data structures that can support efficient symbol-table implementations: binary search trees, red -black trees and hash tables.</description>
    </item>
    
  </channel>
</rss>
