<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on savchenko.tech</title>
    <link>https://savchenko.tech/tags/algorithms/</link>
    <description>Recent content in algorithms on savchenko.tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://savchenko.tech/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Red black binary search tree: Part 2 delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst2/</link>
      <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst2/</guid>
      <description>To implement delete() method we need to take care about helper methods first. First we will take a look at deleteMin().
DELETE MIN Test cases for deleteMin() should check that:
 minimal element is not present tree is balanced, which means:  there is no more than 1 left RED links in the row there is no right RED link root should be always BLACK     @Test  void shouldDeleteMinElement() {  RedBlackBinarySearchTree&amp;lt;Integer, String&amp;gt; brBinarySearchTree = createRedBlackBST();   brBinarySearchTree.</description>
    </item>
    
    <item>
      <title>Red black binary search tree: Part 1 put. Algorithms series</title>
      <link>https://savchenko.tech/posts/rbbst/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/rbbst/</guid>
      <description>Red-black tree is a binary search tree with one extra bit of storage per node - color, which can be either RED or BLACK. We need it to keep BST &amp;ldquo;balanced&amp;rdquo;, that means basic dynamic set operations will be fast (guaranteed time O(lg n) ).
Red-black tree has next properties:
 Every node is RED or BLACK The root id always BlACK Every null leaf is black If a node is RED, then both children are BLACK For each node, all simple paths from the node to descendant leaves contain the same number of BLACK nodes.</description>
    </item>
    
    <item>
      <title>Binary search tree: Part 2 min, floor, delete. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst2/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst2/</guid>
      <description>An important feature of Binary search tree (BST) is that it allows keeping keys in order. So we are able to apply wide range of operations that involves relative key order.
In this article we will take a look at some of them.
As in the previous part we will use TDD to ensure algorithm correctness.
MIN min() method should return the smallest key.
 @Test  void shouldReturnMinKeyInBST() {  BinarySearchTree&amp;lt;Integer, String&amp;gt; bst = new BinarySearchTree&amp;lt;&amp;gt;();  bst.</description>
    </item>
    
    <item>
      <title>Binary search tree: Part 1 put, get, size. Algorithms series</title>
      <link>https://savchenko.tech/posts/bst/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://savchenko.tech/posts/bst/</guid>
      <description>Development of computational infrastructure would not become available without effective searching algorithms. One type of such algorithms is symbol tables. Term symbol table is used to describe a mechanism where we can save information (value) and later retrieve it by specified key. Symbol tables sometimes also referred as dictionaries.
There are three main classic data structures that can support efficient symbol-table implementations: binary search trees, red -black trees and hash tables.</description>
    </item>
    
  </channel>
</rss>
