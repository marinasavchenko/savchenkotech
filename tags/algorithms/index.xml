<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on savchenko.tech</title>
    <link>https://savchenko.tech/tags/algorithms/</link>
    <description>Recent content in algorithms on savchenko.tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 06 Aug 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://savchenko.tech/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reduction. Algorithm Series</title>
      <link>https://savchenko.tech/posts/reduction/</link>
      <pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/reduction/</guid>
      <description>Reduction is a basic technique in algorithm design.&#xA;A problem A reduces to problem B if we can use an algorithm that solves B to develop an algorithm that solves A.&#xA;This concept should be pretty familiar in software development. For example, when you use method evaluate() of Apache Commons library to solve a problem, your problem is reduced to the one solved by library method.&#xA;Simple example of reduction would be finding a median in a collection.</description>
    </item>
    <item>
      <title>Topological Sort. Algorithms Series</title>
      <link>https://savchenko.tech/posts/topsort/</link>
      <pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/topsort/</guid>
      <description>Topological sort can be applied in scheduling problems.&#xA;Those types of problems can be solved when:&#xA;tasks and precedence constraints are defined; cycles are detected and removed. Implementation of cycle detection can be found here.&#xA;Test should check that reverse post order is correct.&#xA;@Test void shouldReturnPostOrder() { DirectedGraph directedGraph = new DirectedGraph(4); directedGraph.addEdge(1, 0); directedGraph.addEdge(0, 3); directedGraph.addEdge(1, 2); TopologicalSort topologicalSort = new TopologicalSort(directedGraph); LinkedList&amp;lt;Integer&amp;gt; expected = new LinkedList&amp;lt;&amp;gt;(Arrays.asList(3, 0, 2, 1)); assertEquals(expected, topologicalSort.</description>
    </item>
    <item>
      <title>Linked List. Algorithms Series</title>
      <link>https://savchenko.tech/posts/linledlist/</link>
      <pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/linledlist/</guid>
      <description>A Linked List is fundamental and incredibly useful. It enables implementation of bags, queues and stacks.&#xA;It is a recursive data structure. In the core of Linked List is Node that contains of generic item and reference to the next node.&#xA;Node abstraction would be a nested class in Linked List and would look like this:&#xA;private static class Node&amp;lt;E&amp;gt; { E value; Node&amp;lt;E&amp;gt; next; public Node(E value) { this.value = value; } } Insertion an element to the beginning of the Linked List.</description>
    </item>
    <item>
      <title>Prim&#39;s Algorithm. Greedy. Algorithms Series</title>
      <link>https://savchenko.tech/posts/greedy/</link>
      <pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/greedy/</guid>
      <description>Prim&amp;rsquo;s algorithm is a greedy algorithm for computing Minimum Spanning Tree (MST).&#xA;Greedy algorithms is a technique used in designing and analyzing efficient algorithms. They typically apply to optimization problems in which you make a set of choices in order to arrive at an optimal solution. A greedy algorithm always makes the choice that looks best at the moment. It makes a locally optimal choice in hope that this choice leads to globally optimal solution.</description>
    </item>
    <item>
      <title>Breadth First Search. Algorithms Series</title>
      <link>https://savchenko.tech/posts/bfs/</link>
      <pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/bfs/</guid>
      <description>In this article we will be looking at Single-source shortest path problem. The classical method for solving it is Breadth First Search (BFS). In BFS we want to explore the vertices in order of their distance from the source. It could be achieved with queue and filling in last edge on the shortest path for every vertex.&#xA;Unit test should check if the shortest path is returned, when there is longer path in the graph.</description>
    </item>
    <item>
      <title>Depth First Search. Algorithms Series</title>
      <link>https://savchenko.tech/posts/dfs/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/dfs/</guid>
      <description>Graph algorithms solve many problems in computer science and are fundamental to the field. Depth First Search (DFS) is one of them.&#xA;Representation of a graph Before we dive into DFS we need to understand Graph structure and terminology.&#xA;Graph is a set of vertices and a collection of edges that each connect a pair of vertices.&#xA;Examples of a Graph would be:&#xA;in finance : Currency is a vertex, transaction is an edge in transportation : Street intersection is a vertex, route is an edge Vertex 1 is connected to Vertex 2 when there is an edge between them.</description>
    </item>
    <item>
      <title>Hash Table. Algorithms Series</title>
      <link>https://savchenko.tech/posts/hashtable/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/hashtable/</guid>
      <description>Dictionary operations (INSERT, SEARCH and DELETE) are required by many applications. One very effective data structures for implementing dictionaries is hash table. The average time to search for an element in hash table is O(1).&#xA;Hash table ia unordered symbol table where key is interpreted as an array index and value associated with key &amp;lsquo;i&amp;rsquo; is stored in array entry &amp;lsquo;i&amp;rsquo;.&#xA;Two main parts in hash algorithm are hash function and collision resolution method.</description>
    </item>
    <item>
      <title>Red Black Binary Search Tree: Part 2 delete. Algorithms Series</title>
      <link>https://savchenko.tech/posts/rbbst2/</link>
      <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/rbbst2/</guid>
      <description>To implement delete() method we need to take care about helper methods first. First we will take a look at deleteMin().&#xA;DELETE MIN Test cases for deleteMin() should check that:&#xA;minimal element is not present tree is balanced, which means: there is no more than 1 left RED links in the row there is no right RED link root should be always BLACK @Test void shouldDeleteMinElement() { RedBlackBinarySearchTree&amp;lt;Integer, String&amp;gt; brBinarySearchTree = createRedBlackBST(); brBinarySearchTree.</description>
    </item>
    <item>
      <title>Red Black Binary Search Tree: Part 1 put. Algorithms Series</title>
      <link>https://savchenko.tech/posts/rbbst/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/rbbst/</guid>
      <description>Red-Black Tree is a Binary Search Tree with one extra bit of storage per node - color, which can be either RED or BLACK. We need it to keep BST &amp;ldquo;balanced&amp;rdquo;, that means basic dynamic set operations will be fast (guaranteed time O(lg n) ).&#xA;Red-black tree has next properties:&#xA;Every node is RED or BLACK The root id always BlACK Every null leaf is black If a node is RED, then both children are BLACK For each node, all simple paths from the node to descendant leaves contain the same number of BLACK nodes.</description>
    </item>
    <item>
      <title>Binary Search Tree: Part 2 min, floor, delete. Algorithms Series</title>
      <link>https://savchenko.tech/posts/bst2/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/bst2/</guid>
      <description>An important feature of Binary Search Tree (BST) is that it allows keeping keys in order. So we are able to apply wide range of operations that involves relative key order.&#xA;In this article we will take a look at some of them.&#xA;As in the previous part we will use TDD to ensure algorithm correctness.&#xA;MIN min() method should return the smallest key.&#xA;@Test void shouldReturnMinKeyInBST() { BinarySearchTree&amp;lt;Integer, String&amp;gt; bst = new BinarySearchTree&amp;lt;&amp;gt;(); bst.</description>
    </item>
    <item>
      <title>Binary Search Tree: Part 1 put, get, size. Algorithms Series</title>
      <link>https://savchenko.tech/posts/bst/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      <guid>https://savchenko.tech/posts/bst/</guid>
      <description>Development of computational infrastructure would not become available without effective searching algorithms. One type of such algorithms is symbol tables. Term symbol table is used to describe a mechanism where we can save information (value) and later retrieve it by specified key. Symbol tables sometimes also referred as dictionaries.&#xA;There are three main classic data structures that can support efficient symbol-table implementations: binary search trees, red -black trees and hash tables.</description>
    </item>
  </channel>
</rss>
